#!/bin/bash
# bt.sh v1.0
# Small application to manage bluetooth devices
#
#                                    NOTES 
#-------------------------------------------------------------------------------
# Config file should be in the format of:
#  phone=3C:28:6D:F6:22:0F
#  headphones=00:02:5B:D3:34:75
# You can use a multi-word key, though it makes it more difficult to
# type on the command line when connecting to the device. Comments are
# stripped.
#
# Still not entirely sure how to manage this. It's supposed to be a
# clear and concise wrapper around bluetoothctl, making it easier to
# quickly connect to a known BT device.
#
# I feel the config file may add an extra unnecessary step, as running
# `bluetoothctl devices` pretty much accomplishes the same thing.
# Maybe tab-completing the friendly name will actually auto-populate
# the identifier on the command line?
#
# The config file effectively switches which is the "key". Reading from btctl's
# output, the key must be the identifier. For the config file, it maps a unique
# friendly name to the id.
#
# Maybe both? First try to see if there's a matching entry in the config file,
# if not try to do it based on the ID directly? Effectively it's to create a
# "shortcut".
#
# Been working on the completion script in ./completion/_bt.sh, and it's been...
# rough. Unsure how to best implement it. Had a good idea for using colored
# output from CLI completion, but `complete` can only do raw text.
#
# I think I have the _skeleton_ for a pretty solid wrapper around bluetoothctl.
#
#                                     TODO
#-------------------------------------------------------------------------------


rs="\033[0m"      # Reset
gr="\033[32m"     # Green
rd="\033[31m"     # Red
yl="\033[33m"     # Yellow
bk="\033[30m"     # Black (dim)
br="\033[37;1m"   # White (bright)


conf_dir="${HOME}/.config/hre-utils"
[[ ! -d "$conf_dir" ]] && {
   mkdir -p "$conf_dir"
   printf "${br} ◆${rs} Created ${br}${conf_dir}${rs}\n"
}


conf_file="${conf_dir}/bt.conf"
[[ ! -f "$conf_file" ]] && {
   touch "$conf_file"
   printf "${br} ◆${rs} Created ${br}${conf_file}${rs}.\n"
}


[[ ! $(cat "$conf_file") ]] && {
   printf "${yl} ◆${rs} Config file empty\n"
}


load_config()
{
   while read -r line ; do
      CHAR1=$( sed -E 's/(.).*/\1/g' <<< "$line" )
      [[ "$CHAR1" == '#' ]] && continue

      IFS='=' read -r key value <<< "$line"
      device_map["${key}"]="$value"
   done < "$conf_file"
}


list_devices() {
   # Devices in `bluetoothctl`
   mapfile devices < <(bluetoothctl devices)
   printf "${gr} ◆${rs} bluetoothctl devices\n"

   for (( i=0; i<${#devices[*]}; i++ )) ; do
      line="${devices[$i]}"

      tree='├─'
      [[ $i -eq $(( ${#devices[@]} - 1 )) ]] && tree='└─'

      read _ identifier name <<< "$line"
      printf "     ${bk}${tree}${rs} $identifier  $name\n"
   done

   # Devices in config file
   printf "${gr} ◆${rs} config devices\n"

   idx=0
   for name in "${!device_map[@]}" ; do
      identifier="${device_map[${name}]}" 

      tree='├─'
      [[ $idx -eq $(( ${#device_map[@]} - 1 )) ]] && tree='└─'
      ((idx++))

      printf "     ${bk}${tree}${rs} $identifier  $name\n"
   done
}


connect_to() {
   name="$1"

   identifier="${device_map[${name}]-}"
   [[ -z "$identifier" ]] && {
      printf "${rd} ◆${rs} Option or command \"${br}$1${rs}\" unknown\n"
      exit 1
   }

   printf "${gr} ◆${rs} "
   sudo bluetoothctl --timeout 3 connect $identifier

   [[ $? -ne 0 ]] && printf "${rd} ◆${rs} Failed to connect to $name"
}


declare -A device_map
load_config


case "$1" in
   'ls')
      list_devices
      ;;
   'on')
      sudo bluetoothctl power on &>/dev/null
      printf "${gr} ◆${rs} Power on\n"
      ;;
   'off')
      sudo bluetoothctl power off &>/dev/null
      printf "${rd} ◆${rs} Power off\n"
      ;;
   'alias')
      sudo bluetoothctl alias "$1"
      ;;
   *)
      connect_to "$1"
   ;;
esac
